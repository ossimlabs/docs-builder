<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:p="http://www.springframework.org/schema/p" xmlns:c="http://www.springframework.org/schema/c"
	xmlns:util="http://www.springframework.org/schema/util" xmlns:rbf="http://www.radiantblue.com/schema/rb/foundation"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.1.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util-3.1.xsd
        http://www.radiantblue.com/schema/rb/foundation
        http://www.radiantblue.com/schema/rb/foundation/rb-foundation-1.0.xsd">

	<context:property-placeholder />
	<context:annotation-config />
	
	<util:map id="assetGroups">
		<entry key="airsar">
			<list>
				<value>AIR_SAR_1</value>
				<value>AIR_SAR_2</value>
				<value>AIR_SAR_3</value>
				<value>AIR_SAR_4</value>
				<value>AIR_SAR_5</value>
				<value>AIR_SAR_6</value>
				<value>AIR_SAR_7</value>
				<value>AIR_SAR_8</value>
				<value>AIR_SAR_9</value>
				<value>AIR_SAR_10</value>
				<value>AIR_SAR_11</value>
				<value>AIR_SAR_12</value>
				<value>AIR_SAR_13</value>
				<value>AIR_SAR_14</value>
				<value>AIR_SAR_15</value>
				<value>AIR_SAR_16</value>
				<value>AIR_SAR_17</value>
				<value>AIR_SAR_18</value>
				<value>AIR_SAR_19</value>
				<value>AIR_SAR_20</value>
				<value>AIR_SAR_21</value>
				<value>AIR_SAR_22</value>
				<value>AIR_SAR_23</value>
				<value>AIR_SAR_24</value>
				<value>AIR_SAR_25</value>
			</list>
		</entry>
		<entry key="csm">
			<list>
				<value>CSM1</value>
				<value>CSM2</value>
				<value>CSM3</value>
				<value>CSM4</value>
			</list>
		</entry>
		<entry key="dg">
			<list>
				<value>GE01</value>
				<value>WV01</value>
				<value>WV02</value>
				<value>WV03</value>
				<value>WV04</value>
				<value>WV04_CLONE</value>
			</list>
		</entry>
	</util:map>
	
	<!-- choose moon propagator (with bean name moonPropagator) -->
	<bean id="otherOption"
		class="com.radiantblue.analytics.mechanics.lunar.PreciseMoonModel" />

	<bean id="moonPropagator"
		class="com.radiantblue.analytics.mechanics.lunar.JPLTableMoonModel">
		<property name="timeStep">
			<rbf:timespan units="hours" value="1" />
		</property>
	</bean>

	<bean id="factory" class="com.radiantblue.analytics.isr.C4ISRFactory">

		
	</bean>

	<bean id="accessGenerator"
		class="com.radiantblue.analytics.isr.component.accgen.BulkClusterAccessGenerator"
		scope="prototype">
		<property name="packetSize" value="8" />

		<!-- This is the priority of the accessGenerator relative to other users 
			of the clusterSystem. Default Value: Int.MaxValue, which makes it the lowest 
			priority item <property name="priority" value="${schedulerconfig.accgen.clusterpriority}"/> -->

		<!-- This is the accessRequestSplitThreshold, which is applied to access 
			requests. Access requests greater than this value will be split into smaller 
			requests and processed in parallel Default Value: 15 minutes <property name="accessRequestSplitThreshold"> 
			<rbf:timespan units="millisecs" value="${schedulerConfig.accessRequestSplitThresholdMillis}"/> 
			</property> -->

		<!-- This is the minimum acceptable access duration to be considered 'valid'. 
			Accesses less than this threshold are filtered out. Default Value: 0 zeconds 
			<property name="minAccessDuration"> <rbf:timespan units="millisecs" value="${schedulerConfig.minAccessDurationMillis}"/> 
			</property> -->

		<!-- the accessGenerators list is processed in order, meaning that the 
			first one to declare that it can handle an AccessRequest will get it -->
		<property name="accessGenerators">
			<list>
				<!-- The TargetWithGeometryAccessGenerator will generate accesses to 
					area targets. -->
				<bean id="TargetWithGeometryAccessGenerator"
					class="com.radiantblue.analytics.isr.core.component.accgen.area.TargetWithGeometryAccessGenerator" >

					<!-- The geoPointAccessCombiner is a class name to determine how to 
						combine the separate accesses together. Valid implementations are: com.radiantblue.analytics.core.joda.IntersectOverlappingIntervals 
						com.radiantblue.analytics.core.joda.UnionOverlappingIntervals IntersectOverlappingIntervals 
						will give you an access that represents the time you can see the entire target 
						UnionOverlappingIntervals will give you an access that represents the time 
						you can see any part of the target -->
					<property name="geoPointAccessCombiner">
						<bean
							class="com.radiantblue.analytics.core.joda.UnionOverlappingIntervals" />
					</property>

					<!-- The accessSampleStepSelector will determine the sample rate that 
						the Access Generator checks for access -->
					<property name="accessSampleStepSelector">
						<bean
							class="com.radiantblue.analytics.isr.core.component.accgen.SpecifiedAccessSampleStepSelector">
							<property name="sampleStep">
								<rbf:timespan units="seconds"
									value="5" />
							</property>
						</bean>
					</property>

					<!-- The minPolygonArea defines the minimum area threshold for this access 
						generator to take effect -->
					<property name="minPolygonArea">
						<rbf:area units="km_squared"
							value="100" />
					</property>

					<!-- This access generator works by sampling the edges of the polygon. 
						This parameter determines the spacing of those samples -->
					<property name="areaPolygonSampleLength">
						<rbf:length units="km"
							value="1" />
					</property>
				</bean>

				<!-- the PointToPointAccessGenerator generates accesses to the centroid 
					of targets. It is the default and will handle any access requests that are 
					not handled by prior access generators -->
				<bean
					class="com.radiantblue.analytics.isr.core.component.accgen.point.PointToPointAccessGenerator">
					<!-- The accessSampleStepSelector will determine the sample rate that 
						the Access Generator checks for access -->
					<property name="accessSampleStepSelector">
						<bean
							class="com.radiantblue.analytics.isr.core.component.accgen.SpecifiedAccessSampleStepSelector">
							<property name="sampleStep">
								<rbf:timespan units="seconds"
									value="5" />
							</property>
						</bean>
					</property>
				</bean>
			</list>
		</property>

		<!-- the observers collection is invoked every time access generation completes. 
			The default list will log all 'failed' accesses to the console using Log4j -->
			
	<!--
		<property name="observers">
			<list>
				<bean
					class="com.radiantblue.analytics.isr.core.component.accgen.observers.Log4jFailedAccessObserver" />
			</list>
		</property>
	-->
	</bean>

	<bean id="riseSetGenerator"
		class="com.radiantblue.analytics.isr.component.riseset.RiseSetGenerator">
		<property name="defaultRiseSetGenerator">
			<bean
				class="com.radiantblue.analytics.isr.component.riseset.SubGeoRiseSetGenerator">
				<property name="searchStep">
					<rbf:timespan units="minutes"
						value="1" />
				</property>
			</bean>
		</property>

		<property name="specializedRiseSetGenerators">
			<list>
				<!-- handles rise/set generation for assets that are in highly elliptical 
					orbits that go above the Geostationary altitude. Many of the tricks that 
					are used in the SubGeoRiseSetGenerator are not applicable at this altitude 
					because the groundtrack starts moving backward as the earth spins. -->
				<bean
					class="com.radiantblue.analytics.isr.component.riseset.SuperGeoRiseSetGenerator">
					<property name="searchStep">
						<rbf:timespan units="minutes"
							value="1" />
					</property>
				</bean>

				<!-- handles targets with an area greater than a theshold by sampling 
					the polygon and calculating rise/sets to each point -->
				<bean
					class="com.radiantblue.analytics.isr.component.riseset.TargetWithGeometryRiseSetGenerator">
					<property name="geoPointRiseSetGenerator">
						<bean
							class="com.radiantblue.analytics.isr.component.riseset.SubGeoRiseSetGenerator">
							<property name="searchStep">
								<rbf:timespan units="minutes"
									value="1" />
							</property>
							
						</bean>
					</property>
					
					<!-- this is the minimum polygon area in which this rise/set generator 
						takes effect it should be synchronized with the AccessGenerator for large 
						areas -->
					<property name="minPolygonArea">
						<rbf:area units="km_squared"
							value="5" />
					</property>
				</bean>
			</list>
		</property>
	</bean>

	<bean id="accessRequestProvider"
		class="com.radiantblue.analytics.isr.core.component.accgen.request.ISRAccessRequestProvider"
		factory-bean="factory" factory-method="createUntrimmedAccessRequestProvider">
	</bean>

	<bean id="greedyAccessScheduler"
		class="com.radiantblue.analytics.isr.core.component.schedule.WindowBasedScheduler">

		<!-- define the schedule period: Schedule requests that are longer than 
			this period are quantized into this value and then processed sequentially -->
		<property name="schedulePeriod">
			<rbf:timespan units="hours"
				value="12" />
		</property>

		<!-- define the internal scheduler used when processing each schedule window -->
		<property name="internalScheduler">
			<bean id="accessScheduler"
				class="com.radiantblue.analytics.isr.component.schedule.GreedyAccessScheduler">
				<!--<property name="opScoreFunction">
					<bean class="com.radiantblue.analytics.isr.core.component.schedule.score.IScoreFunction" />
				</property> -->

				<property name="numStatusMessages" value="10" />

				<property name="accessGrouper">
					<bean class="com.radiantblue.analytics.isr.component.schedule.PriorityScoreAccessGrouper">
						<property name="binSize" value="1000" />
					</bean>					
				</property>

				<property name="extensions">
					<ref bean="schedulerExtensions" />
				</property>
			</bean>
		</property>
	</bean>

	<util:list id="schedulerExtensions">
		<bean
			class="com.radiantblue.analytics.isr.component.schedule.extension.stereo.StereoSchedulerExtension">

			<property name="step">
				<rbf:timespan units="millisecs"
					value="1000" />
			</property>
		</bean>
		<bean
			class="com.radiantblue.analytics.isr.component.schedule.extension.timecoincident.TimeCoincidentSchedulerExtension">
			<property name="opGenerator">
				<bean
					class="com.radiantblue.analytics.isr.component.opgen.ScheduleOpClusterGenerator">
					<property name="clusterSystem" ref="clusterSystem" />
					<property name="packetSize" value="8" />
					<property name="sampleStepSelector">
						<bean
							class="com.radiantblue.analytics.isr.core.component.opgen.SpecifiedOpSampleTimeSelector">
							<property name="sampleStep">
								<rbf:timespan units="millisecs"
									value="1000" />
							</property>
						</bean>
					</property>
				</bean>
			</property>
		</bean>

		<bean
			class="com.radiantblue.analytics.isr.component.schedule.extension.multilook.MultiLookSchedulerExtension">
			<property name="step">
				<rbf:timespan units="millisecs"
					value="1000" />
			</property>
		</bean>
		<bean
			class="com.radiantblue.analytics.isr.component.schedule.extension.coupledcollect.EventCentricCoupledCollectSchedulerExtension">

			<property name="step">
				<rbf:timespan units="millisecs"
					value="1000" />
			</property>
		</bean>
		<bean
			class="com.radiantblue.analytics.isr.component.schedule.extension.coupledcollect.CoupledCollectSchedulerExtension">

			<property name="step">
				<rbf:timespan units="millisecs"
					value="1000" />
			</property>
		</bean>
		<bean
			class="com.radiantblue.analytics.isr.component.schedule.extension.coupledcollect.OverlapCoupledCollectSchedulerExtension">

			<property name="step">
				<rbf:timespan units="millisecs"
					value="1000" />
			</property>
		</bean>
	</util:list>



	<!-- maneuver rates -->
	<bean id="3DegPerSecLimits" class="com.radiantblue.analytics.core.maneuver.r3.RateLimits"
		c:xRate="3.0" c:yRate="3.0" c:zRate="3.0" />

	<bean name="ManeuverModel"
		class="com.radiantblue.analytics.gnc.maneuver.EigenAxisManeuverModel"
		scope="prototype">
		<property name="rateSelector">
			<bean
				class="com.radiantblue.analytics.core.maneuver.r3.EllipsoidalEigenAxisRateSelector">
				<property name="javLimits">
					<bean class="com.radiantblue.analytics.core.maneuver.r3.JAVLimits"
						c:velocityLimits-ref="3DegPerSecLimits" c:accelerationLimits-ref="3DegPerSecLimits"
						c:jerkLimits-ref="3DegPerSecLimits" />
				</property>
			</bean>
		</property>

		<property name="cruiseAttitudeSelector">
			<bean
				class="com.radiantblue.analytics.isr.assets.attitude.SolarTrackingAttitudeSelector">
				<property name="solarPanelMount">
					<bean
						class="com.radiantblue.analytics.isr.core.model.payload.mount.VectorPayloadMount">
						<property name="payloadZInBodyFrame">
							<rbf:vector3d delimeter="," value="1,0,0" />
						</property>
						<property name="payloadYInBodyFrame">
							<rbf:vector3d delimeter="," value="0,-1,0" />
						</property>
						<property name="payloadXInBodyFrame">
							<rbf:vector3d delimeter="," value="0,0,1" />
						</property>
					</bean>
				</property>
			</bean>
		</property>
	</bean>

	<bean id="ignoreThermalValidation" class="java.lang.Boolean">
		<constructor-arg value="true" />
	</bean>
	<bean id="ignorePowerValidation" class="java.lang.Boolean">
		<constructor-arg value="true" />
	</bean>

</beans>